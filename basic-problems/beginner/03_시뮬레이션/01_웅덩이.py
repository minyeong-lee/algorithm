
# 방향벡터를 설정하여 4방향 탐색 준비를 한다
# 이중 포문으로 전체 격자를 탐색하고, 그 안에서 4방향 탐색을 하고
# 하나라도 격자 값보다 작으면 웅덩이로 카운트하지 않는다

# 근데 지금 주변 격자판의 높이가 1000으로 커서 특정 행, 열은
# 한 방향 혹은 두 방향 탐색을 하지 않아도 된다

# 처음부터 웅덩이라고 표시하고, 웅덩이 아닌 경우 break 하는 방법 배움
# nx나 ny가 n이 되는 경우 고려해 줘야함 => 격자 밖으로 나간 것

def solution(nums):
    answer = 0
    n = len(nums)
    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]
    for i in range(n):
        for j in range(n):
            flag = True     # True이면 웅덩이임. 웅덩이라고 가정하고 네 방향 봄
            for k in range(4):
                nx = i + dx[k]
                ny = j + dy[k]
                if nx >= 0 and nx < 5 and ny >= 0 and ny < 5 and nums[i][j] >= nums[nx][ny]:  # 작거나 같은 값이 있어도 웅덩이 아님
                    flag = False
                    break  # 더 확인할 필요 없음
            if flag:  # flag == True 와 같음
                answer += 1
    
    
    return answer

print(solution([[10, 20, 50, 30, 20], [20, 30, 50, 70, 90], [10, 15, 25, 80, 35], [25, 35, 40, 55, 80], [30, 20, 35, 40, 90]]))
print(solution([[80, 25, 10, 65, 100], [20, 10, 32, 70, 33], [45, 10, 88, 9, 90], [10, 35, 10, 55, 66], [10, 84, 65, 88, 99]]))
print(solution([[33, 22, 55, 65, 55], [55, 88, 99, 12, 19], [18, 33, 25, 57, 77], [46, 78, 54, 55, 99], [33, 25, 47, 85, 17]]))


# 주의할 점!
# if nx >= 0 and nx < n and ny >= 0 and ny < n and nums[i][j] >= nums[nx][ny]: 
# 위의 조건에서 nums[i][j] >= nums[nx][ny] 를 앞에 쓰면 이미 인덱싱을 하기 때문에 오류 남!
# 앞에서 걸러줘야 한다! 음수는 하지 못하도록!

# 가장자리는 굳이 작은 것을 비교하는 것 안해도 된다 (당연히 커서)
# 비교 안해도 되니까 했다고 생각해도 상관없는 것
# 문제의 로직을 어떻게 정하느냐에 따라 가장자리를 비교해줘야 할지, 안해줘도 될지 결정된다
# 우리는 지금 네 방향 비교해서 웅덩이가 아니다 라는 로직을 짰기에! 당연히 크니까 비교 안해도 괜찮군


# 인사이트
# break로 더 이상 비교하지 않고 반복문을 끝내고 싶다면, 그에 맞는 로직을 짜야 한다
# 인덱스 오류나지 않도록 탐색할 좌표 범위 조건 설정해주기
# 웅덩이인지 아닌지 여부는 True/False 값으로 쉽게 나타낼 수 있다 (Flag)